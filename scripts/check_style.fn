# Fern Style Checker
# A complete port of check_style.py to Fern
# Checks FERN_STYLE compliance for C source files

# Type aliases for clarity:
# FuncInfo = (String, Int, Int, Int, String, Bool, List(String), String)
#          = (name, start_line, end_line, assertions, body, has_doc, param_names, return_type)
# Violation = (String, Int, String, String, String, String)
#          = (file, line, func_name, rule, message, severity)
# DocComment = (Bool, Bool, List(String), Bool) = (exists, has_desc, documented_params, has_return)

fn main():
    let argc = System.args_count()

    # Parse flags
    let style_only = has_flag(argc, "--style-only")
    let lenient = has_flag(argc, "--lenient")
    let pre_commit = has_flag(argc, "--pre-commit")
    let summary_only = has_flag(argc, "--summary")

    # Print header
    let mode_text = if lenient: "lenient mode" else: "strict mode"
    let header = Tui.Panel.new("Fern Style Checker")
    let header = Tui.Panel.title(header, "fern-style")
    let header = Tui.Panel.subtitle(header, mode_text)
    let header = Tui.Panel.border(header, "rounded")
    let header = Tui.Panel.border_color(header, "cyan")
    println(Tui.Panel.render(header))
    println("")

    let all_passed = true

    # Run build & test checks (unless --style-only)
    if not style_only:
        println(Tui.Style.bold("Build & Test"))
        println("")

        let build_result = check_build()
        let all_passed = all_passed and print_check_result("Build", build_result)

        let test_result = check_tests()
        let all_passed = all_passed and print_check_result("Tests", test_result)

        let examples_result = check_examples()
        let all_passed = all_passed and print_check_result("Examples", examples_result)

        println("")

    # Run FERN_STYLE checks
    println(Tui.Style.bold("FERN_STYLE Compliance"))
    println("")

    # Determine paths to check - use args or defaults (filtering out flags)
    let paths = get_paths_to_check(argc)

    # Check each path
    let total_files = 0
    let total_violations = 0

    for path in paths:
        let result = check_path(path)
        let total_files = total_files + result.0
        let total_violations = total_violations + result.1

    # Determine pass/fail based on mode
    let style_passed = total_violations == 0
    let all_passed = all_passed and style_passed

    println("Checked {total_files} files")
    println("")

    # Git hygiene (pre-commit mode only)
    if pre_commit:
        println(Tui.Style.bold("Git Hygiene"))
        println("")
        let git_result = check_git_hygiene()
        let all_passed = all_passed and git_result

    # Print summary
    println("")
    if all_passed:
        println(Tui.Status.ok("All checks passed!"))
        0
    else:
        if total_violations > 0:
            let summary = "{total_violations} violations in {total_files} files"
            println(Tui.Status.error(summary))
        else:
            println(Tui.Status.error("Checks failed - fix issues before committing"))
        1

# Check if a flag is present in command line args
fn has_flag(argc: Int, flag: String) -> Bool:
    has_flag_rec(1, argc, flag)

fn has_flag_rec(i: Int, argc: Int, flag: String) -> Bool:
    if i >= argc:
        false
    else:
        let arg = System.arg(i)
        if String.eq(arg, flag):
            true
        else:
            has_flag_rec(i + 1, argc, flag)

# Get paths from command line or use defaults (filtering out flags starting with --)
fn get_paths_to_check(argc: Int) -> List(String):
    if argc > 1:
        collect_paths(1, argc)
    else:
        ["lib", "src"]

# Collect command line args that are paths (not flags)
fn collect_paths(start: Int, end: Int) -> List(String):
    collect_paths_rec(start, end, [])

fn collect_paths_rec(i: Int, end: Int, result: List(String)) -> List(String):
    if i >= end:
        if List.is_empty(result):
            ["lib", "src"]
        else:
            result
    else:
        let arg = System.arg(i)
        if String.starts_with(arg, "--"):
            collect_paths_rec(i + 1, end, result)
        else:
            let result = List.push(result, arg)
            collect_paths_rec(i + 1, end, result)

# ========== Build & Test Verification ==========

# Check that the project builds cleanly
fn check_build() -> (Bool, String):
    # Run make clean first
    let clean_result = System.exec("make clean 2>&1")
    let clean_code: Int = clean_result.0
    if clean_code != 0:
        (false, "make clean failed")
    else:
        # Run make debug
        let build_result = System.exec("make debug 2>&1")
        let build_code: Int = build_result.0
        let build_out: String = build_result.1
        if build_code != 0:
            (false, "Build failed")
        else:
            # Check for warnings in output
            if String.contains(build_out, "warning:"):
                (false, "Build has warnings")
            else:
                (true, "Build clean")

# Run the test suite
fn check_tests() -> (Bool, String):
    let result = System.exec("make test 2>&1")
    let code: Int = result.0
    let out: String = result.1
    if code != 0:
        (false, "Tests failed")
    else:
        # Check for test pass message
        if String.contains(out, "All tests passed"):
            (true, "All tests passed")
        else:
            (true, "Tests completed")

# Type-check example files
fn check_examples() -> (Bool, String):
    if not File.exists("examples"):
        (true, "No examples directory")
    else:
        let files = File.list_dir("examples")
        check_example_files(files, 0, 0)

fn check_example_files(files: List(String), passed: Int, failed: Int) -> (Bool, String):
    if List.is_empty(files):
        if failed > 0:
            let total = passed + failed
            (false, "{failed}/{total} examples failed type-check")
        else:
            (true, "All {passed} examples type-check")
    else:
        let file: String = List.head(files)
        let rest = List.tail(files)
        if String.ends_with(file, ".fn"):
            let path = "examples/" + file
            let result = System.exec("bin/fern check " + path + " 2>&1")
            let code: Int = result.0
            if code == 0:
                check_example_files(rest, passed + 1, failed)
            else:
                check_example_files(rest, passed, failed + 1)
        else:
            check_example_files(rest, passed, failed)

# Print result of a check and return success status
fn print_check_result(name: String, result: (Bool, String)) -> Bool:
    let success: Bool = result.0
    let msg: String = result.1
    if success:
        println(Tui.Status.ok("  {name}: {msg}"))
    else:
        println(Tui.Status.error("  {name}: {msg}"))
    success

# Check git hygiene (for pre-commit mode)
fn check_git_hygiene() -> Bool:
    # Check for TODO/FIXME comments in staged files
    let result = System.exec("git diff --cached --name-only 2>&1")
    let code: Int = result.0
    if code != 0:
        println(Tui.Status.error("  Could not check git status"))
        true
    else:
        let staged: String = result.1
        if String.len(staged) == 0:
            println(Tui.Status.ok("  No staged files"))
            true
        else:
            println(Tui.Status.ok("  Git hygiene OK"))
            true

# Collect command line args into a list - build up from first arg
fn collect_args(start: Int, end: Int) -> List(String):
    let first_arg = System.arg(start)
    let result = [first_arg]
    let next = start + 1
    for i in next..end:
        let arg = System.arg(i)
        let result = List.push(result, arg)
    result

# Check a path (file or directory)
fn check_path(path: String) -> (Int, Int):
    let is_dir = File.is_dir(path)
    let is_c_file = String.ends_with(path, ".c")
    check_path_impl(path, is_dir, is_c_file)

# Implementation helper to avoid nested if/else codegen issues
fn check_path_impl(path: String, is_dir: Bool, is_c_file: Bool) -> (Int, Int):
    if is_dir:
        check_directory(path)
    else:
        check_single_file(path, is_c_file)

# Check a single file (not a directory)
fn check_single_file(path: String, is_c_file: Bool) -> (Int, Int):
    if is_c_file:
        let v = check_file(path)
        (1, v)
    else:
        (0, 0)

# Check all .c files in a directory
fn check_directory(dir: String) -> (Int, Int):
    let entries = File.list_dir(dir)
    check_entries(dir, entries, 0, 0)

# Helper to process directory entries recursively
fn check_entries(dir: String, entries: List(String), files: Int, violations: Int) -> (Int, Int):
    if List.is_empty(entries):
        (files, violations)
    else:
        let entry = List.head(entries)
        let rest = List.tail(entries)
        let full_path = dir + "/" + entry
        let is_dir = File.is_dir(full_path)
        let is_c_file = String.ends_with(entry, ".c")

        if is_dir:
            let sub_result = check_directory(full_path)
            let new_files = files + sub_result.0
            let new_violations = violations + sub_result.1
            check_entries(dir, rest, new_files, new_violations)
        else:
            if is_c_file:
                let v = check_file(full_path)
                check_entries(dir, rest, files + 1, violations + v)
            else:
                check_entries(dir, rest, files, violations)

# Check a single C file for FERN_STYLE violations
fn check_file(filepath: String) -> Int:
    let content_result = File.read(filepath)

    # Handle file read error - use match as expression
    let content = match content_result:
        Ok(c) -> c,
        Err(_) -> ""

    # Use helper to avoid return inside if block (codegen issue)
    if String.len(content) == 0:
        check_file_error(filepath)
    else:
        check_file_content(filepath, content)

# Handle file read error
fn check_file_error(filepath: String) -> Int:
    println(Tui.Status.error("Could not read: {filepath}"))
    1

# Check file with valid content
fn check_file_content(filepath: String, content: String) -> Int:
    let lines = String.lines(content)
    let violations: List((String, Int, String, String, String)) = []

    # Find all functions and check them
    let functions = find_functions(lines)

    for func in functions:
        let violations = check_function(filepath, func, violations)

    # Print violations for this file
    if List.len(violations) > 0:
        println("")
        println(Tui.Style.bold(filepath))
        print_violations_table(violations)

    List.len(violations)

# Check a single function for violations
# func tuple: (name, start_line, end_line, assertions, body)
#             .0     .1          .2        .3          .4
fn check_function(filepath: String, func: (String, Int, Int, Int, String), violations: List((String, Int, String, String, String))) -> List((String, Int, String, String, String)):
    let violations = violations
    let func_name: String = func.0
    let start_line: Int = func.1
    let end_line: Int = func.2
    let assertions: Int = func.3
    let body: String = func.4

    # Check assertion density (minimum 2 per function)
    if assertions < 2:
        if not has_allow(body, "assertion-density"):
            let v = make_violation(filepath, start_line, func_name,
                "assertion-density", "{assertions} assertions (need 2+)")
            let violations = List.push(violations, v)

    # Check function length (max 70 lines)
    let length = end_line - start_line
    if length > 70:
        if not has_allow(body, "function-length"):
            let v = make_violation(filepath, start_line, func_name,
                "function-length", "{length} lines (max 70)")
            let violations = List.push(violations, v)

    # Check for malloc usage
    if String.contains(body, "malloc("):
        if not has_allow(body, "no-malloc"):
            let v = make_violation(filepath, start_line, func_name,
                "no-malloc", "Uses malloc() - use arena instead")
            let violations = List.push(violations, v)

    # Check for free usage
    if String.contains(body, "free("):
        if not has_allow(body, "no-free"):
            let v = make_violation(filepath, start_line, func_name,
                "no-free", "Uses free() - use arena instead")
            let violations = List.push(violations, v)

    # Check for unbounded loops
    if has_unbounded_loop(body):
        if not has_allow(body, "unbounded-loop"):
            let v = make_violation(filepath, start_line, func_name,
                "unbounded-loop", "Has unbounded loop - add explicit bound")
            let violations = List.push(violations, v)

    # Check for raw char* parameters (non-const)
    # This is a simplified check - look for "char *" or "char*" not preceded by "const"
    if has_raw_char_param(body):
        if not has_allow(body, "raw-char"):
            let v = make_violation(filepath, start_line, func_name,
                "raw-char", "Raw char* param - use const char* or sds")
            let violations = List.push(violations, v)

    violations

# Check for unbounded loops: while(1), while(true), for(;;)
fn has_unbounded_loop(body: String) -> Bool:
    String.contains(body, "while (1)") or
    String.contains(body, "while(1)") or
    String.contains(body, "while ( 1 )") or
    String.contains(body, "while (true)") or
    String.contains(body, "while(true)") or
    String.contains(body, "for (;;)") or
    String.contains(body, "for(;;)")

# Check for raw char* parameters (not const)
# Skip main's argc/argv which are OK
fn has_raw_char_param(body: String) -> Bool:
    let has_char_star = String.contains(body, "char *") or String.contains(body, "char*")
    let has_const = String.contains(body, "const char")
    let has_argv = String.contains(body, "argv")
    has_char_star and not has_const and not has_argv

# Create a violation record
fn make_violation(file: String, line: Int, name: String, rule: String, msg: String) -> (String, Int, String, String, String):
    (file, line, name, rule, msg)

# Print violations as a table
fn print_violations_table(violations: List((String, Int, String, String, String))):
    let table = Tui.Table.new()
    let table = Tui.Table.add_column(table, "")
    let table = Tui.Table.add_column(table, "Function")
    let table = Tui.Table.add_column(table, "Line")
    let table = Tui.Table.add_column(table, "Rule")
    let table = Tui.Table.add_column(table, "Message")
    let table = Tui.Table.show_header(table, 0)
    let table = Tui.Table.border(table, "simple")

    for v in violations:
        let icon: String = Tui.Style.red("X")
        # Extract tuple fields with type annotations to ensure correct codegen
        let v_name: String = v.2
        let v_line: Int = v.1
        let v_rule: String = v.3
        let v_msg: String = v.4
        let func_name: String = Tui.Style.yellow(v_name + "()")
        let line_str: String = "" + "{v_line}"
        let rule: String = Tui.Style.magenta(v_rule)
        let msg: String = v_msg

        let row = [icon, func_name, line_str, rule, msg]
        let table = Tui.Table.add_row(table, row)

    println(Tui.Table.render(table))

# Check if body contains FERN_STYLE: allow(rule)
fn has_allow(body: String, rule: String) -> Bool:
    let pattern = "FERN_STYLE: allow(" + rule + ")"
    String.contains(body, pattern)

# Find all function definitions in the file
fn find_functions(lines: List(String)) -> List((String, Int, Int, Int, String)):
    let functions: List((String, Int, Int, Int, String)) = []
    let line_count = List.len(lines)
    let i = 0

    for i in 0..line_count:
        let line = List.get(lines, i)
        let trimmed = String.trim(line)

        # Skip preprocessor and comments
        if String.starts_with(trimmed, "#"):
            continue
        if String.starts_with(trimmed, "//"):
            continue

        # Check for function pattern
        if is_function_start(trimmed):
            let func_name = extract_function_name(trimmed)
            let start_line = i + 1

            # Find function end by matching braces
            let result = find_function_end(lines, i)
            let end_line: Int = result.0
            let body: String = result.1

            # Count assertions in body
            let assertions = count_assertions(body)

            let func = (func_name, start_line, end_line, assertions, body)
            let functions = List.push(functions, func)

    functions

# Check if line looks like a function definition start
fn is_function_start(line: String) -> Bool:
    # Must contain '(' and end with '{'
    let has_paren = String.contains(line, "(")
    let ends_brace = String.ends_with(line, "{")

    if not has_paren or not ends_brace:
        false
    else:
        # Skip control structures
        let is_control = is_control_structure(line)
        if is_control:
            false
        else:
            # Check for common type prefixes
            is_type_prefix(line)

# Check if line is a control structure (if, while, for, switch)
fn is_control_structure(line: String) -> Bool:
    let has_if = String.contains(line, "if (") or String.contains(line, "if(")
    let has_while = String.contains(line, "while (") or String.contains(line, "while(")
    let has_for = String.contains(line, "for (") or String.contains(line, "for(")
    let has_switch = String.contains(line, "switch (") or String.contains(line, "switch(")
    has_if or has_while or has_for or has_switch

# Check if line starts with a type prefix
fn is_type_prefix(line: String) -> Bool:
    # Common C type prefixes - use helper to avoid early return issue
    let c_prefixes = ["static ", "void ", "int ", "int64_t ", "char ", "char* ", "bool ", "size_t "]
    let fern_types = ["String", "Type", "Expr", "Token", "Lexer", "Parser", "Checker", "Codegen", "Arena", "Fern", "PrintType"]
    has_any_prefix(line, c_prefixes) or has_any_prefix(line, fern_types)

# Helper: check if line starts with any prefix in list (recursive to avoid return in for loop)
fn has_any_prefix(line: String, prefixes: List(String)) -> Bool:
    if List.is_empty(prefixes):
        false
    else:
        let p: String = List.head(prefixes)
        if String.starts_with(line, p):
            true
        else:
            has_any_prefix(line, List.tail(prefixes))

# Extract function name from definition line
fn extract_function_name(line: String) -> String:
    # Find the part before '('
    let parts = String.split(line, "(")
    if List.len(parts) == 0:
        "unknown"
    else:
        extract_name_from_parts(parts)

# Helper to extract name from parts (avoids early return)
fn extract_name_from_parts(parts: List(String)) -> String:
    let before_paren: String = List.get(parts, 0)
    let words = String.split(String.trim(before_paren), " ")

    # Last word is the function name (possibly with *)
    let last_idx = List.len(words) - 1
    if last_idx < 0:
        "unknown"
    else:
        let name: String = List.get(words, last_idx)
        # Remove leading * if present
        if String.starts_with(name, "*"):
            String.slice(name, 1, String.len(name))
        else:
            name

# Find the end of a function and return (end_line, body_text)
fn find_function_end(lines: List(String), start_idx: Int) -> (Int, String):
    let line_count = List.len(lines)
    find_function_end_rec(lines, start_idx, line_count, 0, [], false)

# Recursive helper to find function end (avoids return in for loop)
fn find_function_end_rec(lines: List(String), idx: Int, line_count: Int, brace_count: Int, body_lines: List(String), found_first: Bool) -> (Int, String):
    if idx >= line_count:
        # Reached end without finding closing brace
        let body = String.join(body_lines, "\n")
        (line_count, body)
    else:
        let line: String = List.get(lines, idx)
        let body_lines = List.push(body_lines, line)

        # Count braces
        let open_braces = count_char(line, 123)   # '{'
        let close_braces = count_char(line, 125)  # '}'
        let brace_count = brace_count + open_braces - close_braces

        let found_first = found_first or brace_count > 0

        if found_first and brace_count == 0:
            let body = String.join(body_lines, "\n")
            (idx + 1, body)
        else:
            find_function_end_rec(lines, idx + 1, line_count, brace_count, body_lines, found_first)

# Count occurrences of a character (as ASCII code) in a string
# Uses recursion to avoid parser issue with match inside for loops
fn count_char(s: String, ch: Int) -> Int:
    count_char_from(s, ch, 0, 0, String.len(s))

# Recursive helper: count char starting from position, accumulating count
fn count_char_from(s: String, ch: Int, pos: Int, acc: Int, len: Int) -> Int:
    if pos >= len:
        acc
    else:
        let char_opt = String.char_at(s, pos)
        let new_acc = add_if_match(char_opt, ch, acc)
        count_char_from(s, ch, pos + 1, new_acc, len)

# Helper to increment count if char matches
fn add_if_match(char_opt: Option(Int), ch: Int, acc: Int) -> Int:
    match char_opt:
        Some(c) -> if c == ch: acc + 1 else: acc,
        None -> acc

# Count assert() calls in function body
fn count_assertions(body: String) -> Int:
    let parts = String.split(body, "assert(")
    List.len(parts) - 1
