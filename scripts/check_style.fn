# Fern Style Checker
# A complete port of check_style.py to Fern
# Checks FERN_STYLE compliance for C source files

# Type aliases for clarity:
# FuncInfo = (String, Int, Int, Int, String, Bool, List(String), String, List(String))
#          = (name, start_line, end_line, assertions, body, has_doc, param_names, return_type, doc_params)
# Violation = (String, Int, String, String, String, String)
#          = (file, line, func_name, rule, message, severity)
# DocComment = (Bool, Bool, List(String), Bool) = (exists, has_desc, documented_params, has_return)

fn main():
    let argc = System.args_count()

    # Parse flags
    let style_only = has_flag(argc, "--style-only")
    let lenient = has_flag(argc, "--lenient")
    let pre_commit = has_flag(argc, "--pre-commit")
    let summary_only = has_flag(argc, "--summary")

    # Print header
    let mode_text = if lenient: "lenient mode" else: "strict mode"
    let header = Tui.Panel.new("Fern Style Checker")
    let header = Tui.Panel.title(header, "fern-style")
    let header = Tui.Panel.subtitle(header, mode_text)
    let header = Tui.Panel.border(header, "rounded")
    let header = Tui.Panel.border_color(header, "cyan")
    println(Tui.Panel.render(header))
    println("")

    let all_passed = true

    # Run build & test checks (unless --style-only)
    if not style_only:
        println(Tui.Style.bold("Build & Test"))
        println("")

        let build_result = check_build()
        let all_passed = all_passed and print_check_result("Build", build_result)

        let test_result = check_tests()
        let all_passed = all_passed and print_check_result("Tests", test_result)

        let examples_result = check_examples()
        let all_passed = all_passed and print_check_result("Examples", examples_result)

        println("")

    # Run FERN_STYLE checks
    println(Tui.Style.bold("FERN_STYLE Compliance"))
    println("")

    # Determine paths to check - use args or defaults (filtering out flags)
    let paths = get_paths_to_check(argc)

    # Check each path
    let total_files = 0
    let total_violations = 0

    for path in paths:
        let result = check_path(path)
        let total_files = total_files + result.0
        let total_violations = total_violations + result.1

    # Determine pass/fail based on mode
    let style_passed = total_violations == 0
    let all_passed = all_passed and style_passed

    println("Checked {total_files} files")
    println("")

    # Git hygiene (pre-commit mode only)
    if pre_commit:
        println(Tui.Style.bold("Git Hygiene"))
        println("")
        let git_result = check_git_hygiene()
        let all_passed = all_passed and git_result

    # Print summary
    println("")
    if all_passed:
        println(Tui.Status.ok("All checks passed!"))
        0
    else:
        if total_violations > 0:
            let summary = "{total_violations} violations in {total_files} files"
            println(Tui.Status.error(summary))
        else:
            println(Tui.Status.error("Checks failed - fix issues before committing"))
        1

# Check if a flag is present in command line args
fn has_flag(argc: Int, flag: String) -> Bool:
    has_flag_rec(1, argc, flag)

fn has_flag_rec(i: Int, argc: Int, flag: String) -> Bool:
    if i >= argc:
        false
    else:
        let arg = System.arg(i)
        if String.eq(arg, flag):
            true
        else:
            has_flag_rec(i + 1, argc, flag)

# Get paths from command line or use defaults (filtering out flags starting with --)
fn get_paths_to_check(argc: Int) -> List(String):
    if argc > 1:
        collect_paths(1, argc)
    else:
        ["lib", "src"]

# Collect command line args that are paths (not flags)
fn collect_paths(start: Int, end: Int) -> List(String):
    collect_paths_rec(start, end, [])

fn collect_paths_rec(i: Int, end: Int, result: List(String)) -> List(String):
    if i >= end:
        if List.is_empty(result):
            ["lib", "src"]
        else:
            result
    else:
        let arg = System.arg(i)
        if String.starts_with(arg, "--"):
            collect_paths_rec(i + 1, end, result)
        else:
            let result = List.push(result, arg)
            collect_paths_rec(i + 1, end, result)

# ========== Build & Test Verification ==========

# Check that the project builds cleanly
fn check_build() -> (Bool, String):
    # Run make clean first
    let clean_result = System.exec("make clean 2>&1")
    let clean_code: Int = clean_result.0
    if clean_code != 0:
        (false, "make clean failed")
    else:
        # Run make debug
        let build_result = System.exec("make debug 2>&1")
        let build_code: Int = build_result.0
        let build_out: String = build_result.1
        if build_code != 0:
            (false, "Build failed")
        else:
            # Check for warnings in output
            if String.contains(build_out, "warning:"):
                (false, "Build has warnings")
            else:
                (true, "Build clean")

# Run the test suite
fn check_tests() -> (Bool, String):
    let result = System.exec("make test 2>&1")
    let code: Int = result.0
    let out: String = result.1
    if code != 0:
        (false, "Tests failed")
    else:
        # Check for test pass message
        if String.contains(out, "All tests passed"):
            (true, "All tests passed")
        else:
            (true, "Tests completed")

# Type-check example files
fn check_examples() -> (Bool, String):
    if not File.exists("examples"):
        (true, "No examples directory")
    else:
        let files = File.list_dir("examples")
        check_example_files(files, 0, 0)

fn check_example_files(files: List(String), passed: Int, failed: Int) -> (Bool, String):
    if List.is_empty(files):
        if failed > 0:
            let total = passed + failed
            (false, "{failed}/{total} examples failed type-check")
        else:
            (true, "All {passed} examples type-check")
    else:
        let file: String = List.head(files)
        let rest = List.tail(files)
        if String.ends_with(file, ".fn"):
            let path = "examples/" + file
            let result = System.exec("bin/fern check " + path + " 2>&1")
            let code: Int = result.0
            if code == 0:
                check_example_files(rest, passed + 1, failed)
            else:
                check_example_files(rest, passed, failed + 1)
        else:
            check_example_files(rest, passed, failed)

# Print result of a check and return success status
fn print_check_result(name: String, result: (Bool, String)) -> Bool:
    let success: Bool = result.0
    let msg: String = result.1
    if success:
        println(Tui.Status.ok("  {name}: {msg}"))
    else:
        println(Tui.Status.error("  {name}: {msg}"))
    success

# Check git hygiene (for pre-commit mode)
fn check_git_hygiene() -> Bool:
    # Check for TODO/FIXME comments in staged files
    let result = System.exec("git diff --cached --name-only 2>&1")
    let code: Int = result.0
    if code != 0:
        println(Tui.Status.error("  Could not check git status"))
        true
    else:
        let staged: String = result.1
        if String.len(staged) == 0:
            println(Tui.Status.ok("  No staged files"))
            true
        else:
            println(Tui.Status.ok("  Git hygiene OK"))
            true

# Collect command line args into a list - build up from first arg
fn collect_args(start: Int, end: Int) -> List(String):
    let first_arg = System.arg(start)
    let result = [first_arg]
    let next = start + 1
    for i in next..end:
        let arg = System.arg(i)
        let result = List.push(result, arg)
    result

# Check a path (file or directory)
fn check_path(path: String) -> (Int, Int):
    let is_dir = File.is_dir(path)
    let is_c_file = String.ends_with(path, ".c")
    check_path_impl(path, is_dir, is_c_file)

# Implementation helper to avoid nested if/else codegen issues
fn check_path_impl(path: String, is_dir: Bool, is_c_file: Bool) -> (Int, Int):
    if is_dir:
        check_directory(path)
    else:
        check_single_file(path, is_c_file)

# Check a single file (not a directory)
fn check_single_file(path: String, is_c_file: Bool) -> (Int, Int):
    if is_c_file:
        let v = check_file(path)
        (1, v)
    else:
        (0, 0)

# Check all .c files in a directory
fn check_directory(dir: String) -> (Int, Int):
    let entries = File.list_dir(dir)
    check_entries(dir, entries, 0, 0)

# Helper to process directory entries recursively
fn check_entries(dir: String, entries: List(String), files: Int, violations: Int) -> (Int, Int):
    if List.is_empty(entries):
        (files, violations)
    else:
        let entry = List.head(entries)
        let rest = List.tail(entries)
        let full_path = dir + "/" + entry
        let is_dir = File.is_dir(full_path)
        let is_c_file = String.ends_with(entry, ".c")

        if is_dir:
            let sub_result = check_directory(full_path)
            let new_files = files + sub_result.0
            let new_violations = violations + sub_result.1
            check_entries(dir, rest, new_files, new_violations)
        else:
            if is_c_file:
                let v = check_file(full_path)
                check_entries(dir, rest, files + 1, violations + v)
            else:
                check_entries(dir, rest, files, violations)

# Check a single C file for FERN_STYLE violations
fn check_file(filepath: String) -> Int:
    let content_result = File.read(filepath)

    # Handle file read error - use match as expression
    let content = match content_result:
        Ok(c) -> c,
        Err(_) -> ""

    # Use helper to avoid return inside if block (codegen issue)
    if String.len(content) == 0:
        check_file_error(filepath)
    else:
        check_file_content(filepath, content)

# Handle file read error
fn check_file_error(filepath: String) -> Int:
    println(Tui.Status.error("Could not read: {filepath}"))
    1

# Check file with valid content
fn check_file_content(filepath: String, content: String) -> Int:
    let lines = String.lines(content)
    let violations: List((String, Int, String, String, String)) = []

    # Check for manual tagged unions at file level
    let violations = check_tagged_unions(filepath, content, violations)

    # Find all functions and check them
    let functions = find_functions(lines)

    for func in functions:
        let violations = check_function(filepath, func, violations)

    # Print violations for this file
    if List.len(violations) > 0:
        println("")
        println(Tui.Style.bold(filepath))
        print_violations_table(violations)

    List.len(violations)

# Check for manual tagged union patterns
# Looks for: enum {...} kind; or enum {...} tag; or enum {...} type;
fn check_tagged_unions(filepath: String, content: String, violations: List((String, Int, String, String, String))) -> List((String, Int, String, String, String)):
    if has_allow(content, "no-tagged-union"):
        violations
    else:
        # Check for common tagged union patterns
        let has_kind = String.contains(content, "} kind;")
        let has_tag = String.contains(content, "} tag;")
        let has_type_field = String.contains(content, "} type;")

        if has_kind or has_tag or has_type_field:
            # Find the line number (approximate - first occurrence)
            let lines = String.lines(content)
            let line_num = find_tagged_union_line(lines, 0)
            let v = make_violation(filepath, line_num, "",
                "no-tagged-union", "Manual tagged union detected - use Datatype99 instead")
            List.push(violations, v)
        else:
            violations

# Find the line containing a tagged union pattern
fn find_tagged_union_line(lines: List(String), idx: Int) -> Int:
    if List.is_empty(lines):
        1
    else:
        let line: String = List.head(lines)
        let has_kind = String.contains(line, "} kind;")
        let has_tag = String.contains(line, "} tag;")
        let has_type = String.contains(line, "} type;")
        if has_kind or has_tag or has_type:
            idx + 1
        else:
            find_tagged_union_line(List.tail(lines), idx + 1)

# Check a single function for violations
# func tuple: (name, start_line, end_line, assertions, body, has_doc, param_names, return_type, doc_params)
#             .0     .1          .2        .3          .4     .5       .6           .7           .8
fn check_function(filepath: String, func: (String, Int, Int, Int, String, Bool, List(String), String, List(String)), violations: List((String, Int, String, String, String))) -> List((String, Int, String, String, String)):
    let violations = violations
    let func_name: String = func.0
    let start_line: Int = func.1
    let end_line: Int = func.2
    let assertions: Int = func.3
    let body: String = func.4
    let has_doc: Bool = func.5
    let param_names: List(String) = func.6
    let return_type: String = func.7
    let doc_params: List(String) = func.8

    # Check assertion density (minimum 2 per function)
    if assertions < 2:
        if not has_allow(body, "assertion-density"):
            let v = make_violation(filepath, start_line, func_name,
                "assertion-density", "{assertions} assertions (need 2+)")
            let violations = List.push(violations, v)

    # Check function length (max 70 lines)
    let length = end_line - start_line
    if length > 70:
        if not has_allow(body, "function-length"):
            let v = make_violation(filepath, start_line, func_name,
                "function-length", "{length} lines (max 70)")
            let violations = List.push(violations, v)

    # Check for malloc usage
    if String.contains(body, "malloc("):
        if not has_allow(body, "no-malloc"):
            let v = make_violation(filepath, start_line, func_name,
                "no-malloc", "Uses malloc() - use arena instead")
            let violations = List.push(violations, v)

    # Check for free usage
    if String.contains(body, "free("):
        if not has_allow(body, "no-free"):
            let v = make_violation(filepath, start_line, func_name,
                "no-free", "Uses free() - use arena instead")
            let violations = List.push(violations, v)

    # Check for unbounded loops
    # Accept both "unbounded-loop" and "bounded-loops" as exception rules
    if has_unbounded_loop(body):
        let allowed = has_allow(body, "unbounded-loop") or has_allow(body, "bounded-loops")
        if not allowed:
            let v = make_violation(filepath, start_line, func_name,
                "unbounded-loop", "Has unbounded loop - add explicit bound")
            let violations = List.push(violations, v)

    # Check for raw char* parameters (non-const)
    # This is a simplified check - look for "char *" or "char*" not preceded by "const"
    if has_raw_char_param(body):
        if not has_allow(body, "raw-char"):
            let v = make_violation(filepath, start_line, func_name,
                "raw-char", "Raw char* param - use const char* or sds")
            let violations = List.push(violations, v)

    # Check for doc comment
    let violations = check_doc_comment_violations(filepath, start_line, func_name, body, has_doc, param_names, return_type, doc_params, violations)

    violations

# Check doc comment related violations
fn check_doc_comment_violations(filepath: String, line: Int, func_name: String, body: String, has_doc: Bool, param_names: List(String), return_type: String, doc_params: List(String), violations: List((String, Int, String, String, String))) -> List((String, Int, String, String, String)):
    if not has_doc:
        if not has_allow(body, "doc-comment"):
            let v = make_violation(filepath, line, func_name,
                "doc-comment", "Missing doc comment (add /** ... */ before function)")
            List.push(violations, v)
        else:
            violations
    else:
        # Check for missing @param documentation
        let violations = check_doc_params(filepath, line, func_name, body, param_names, doc_params, violations)
        # Check for missing @return documentation
        check_doc_return(filepath, line, func_name, body, return_type, violations)

# Check that all function parameters are documented with @param
fn check_doc_params(filepath: String, line: Int, func_name: String, body: String, param_names: List(String), doc_params: List(String), violations: List((String, Int, String, String, String))) -> List((String, Int, String, String, String)):
    if has_allow(body, "doc-params") or has_allow(body, "doc-style"):
        violations
    else:
        check_doc_params_rec(filepath, line, func_name, param_names, doc_params, violations)

fn check_doc_params_rec(filepath: String, line: Int, func_name: String, param_names: List(String), doc_params: List(String), violations: List((String, Int, String, String, String))) -> List((String, Int, String, String, String)):
    if List.is_empty(param_names):
        violations
    else:
        let param: String = List.head(param_names)
        let rest = List.tail(param_names)
        if list_contains_string(doc_params, param):
            check_doc_params_rec(filepath, line, func_name, rest, doc_params, violations)
        else:
            let v = make_violation(filepath, line, func_name,
                "doc-params", "Missing @param for: {param}")
            let violations = List.push(violations, v)
            check_doc_params_rec(filepath, line, func_name, rest, doc_params, violations)

# Check that non-void functions have @return documentation
fn check_doc_return(filepath: String, line: Int, func_name: String, body: String, return_type: String, violations: List((String, Int, String, String, String))) -> List((String, Int, String, String, String)):
    if has_allow(body, "doc-return") or has_allow(body, "doc-style"):
        violations
    else:
        # Check if return type is void
        let is_void = String.eq(return_type, "void") or String.eq(return_type, "")
        if is_void:
            violations
        else:
            # Need to check if doc comment has @return - this info would need to be passed
            # For now, we'll check if the body contains @return in a comment
            if String.contains(body, "@return"):
                violations
            else:
                let v = make_violation(filepath, line, func_name,
                    "doc-return", "Missing @return for non-void function")
                List.push(violations, v)

# Check if a string is in a list of strings
fn list_contains_string(list: List(String), s: String) -> Bool:
    if List.is_empty(list):
        false
    else:
        let head: String = List.head(list)
        if String.eq(head, s):
            true
        else:
            list_contains_string(List.tail(list), s)

# Check for unbounded loops: while(1), while(true), for(;;)
fn has_unbounded_loop(body: String) -> Bool:
    String.contains(body, "while (1)") or
    String.contains(body, "while(1)") or
    String.contains(body, "while ( 1 )") or
    String.contains(body, "while (true)") or
    String.contains(body, "while(true)") or
    String.contains(body, "for (;;)") or
    String.contains(body, "for(;;)")

# Check for raw char* parameters (not const)
# Skip main's argc/argv which are OK
fn has_raw_char_param(body: String) -> Bool:
    let has_char_star = String.contains(body, "char *") or String.contains(body, "char*")
    let has_const = String.contains(body, "const char")
    let has_argv = String.contains(body, "argv")
    has_char_star and not has_const and not has_argv

# Create a violation record
fn make_violation(file: String, line: Int, name: String, rule: String, msg: String) -> (String, Int, String, String, String):
    (file, line, name, rule, msg)

# Print violations as a table
fn print_violations_table(violations: List((String, Int, String, String, String))):
    let table = Tui.Table.new()
    let table = Tui.Table.add_column(table, "")
    let table = Tui.Table.add_column(table, "Function")
    let table = Tui.Table.add_column(table, "Line")
    let table = Tui.Table.add_column(table, "Rule")
    let table = Tui.Table.add_column(table, "Message")
    let table = Tui.Table.show_header(table, 0)
    let table = Tui.Table.border(table, "simple")

    for v in violations:
        let icon: String = Tui.Style.red("X")
        # Extract tuple fields with type annotations to ensure correct codegen
        let v_name: String = v.2
        let v_line: Int = v.1
        let v_rule: String = v.3
        let v_msg: String = v.4
        let func_name: String = Tui.Style.yellow(v_name + "()")
        let line_str: String = "" + "{v_line}"
        let rule: String = Tui.Style.magenta(v_rule)
        let msg: String = v_msg

        let row = [icon, func_name, line_str, rule, msg]
        let table = Tui.Table.add_row(table, row)

    println(Tui.Table.render(table))

# Check if body contains FERN_STYLE: allow(rule)
fn has_allow(body: String, rule: String) -> Bool:
    # Check if rule appears within FERN_STYLE: allow(...)
    # The allow can contain multiple rules like allow(assertion-density, function-length)
    # So we check if allow( followed by rule followed by ) or , appears
    let allow_start = "FERN_STYLE: allow("
    if not String.contains(body, allow_start):
        false
    else:
        # Simple approach: check if the rule name appears after "allow(" in the body
        # This works because rule names are unique identifiers
        let has_rule_with_close = String.contains(body, rule + ")")
        let has_rule_with_comma = String.contains(body, rule + ",")
        let has_comma_rule = String.contains(body, ", " + rule)
        has_rule_with_close or has_rule_with_comma or has_comma_rule

# Find all function definitions in the file
fn find_functions(lines: List(String)) -> List((String, Int, Int, Int, String, Bool, List(String), String, List(String))):
    let functions: List((String, Int, Int, Int, String, Bool, List(String), String, List(String))) = []
    let line_count = List.len(lines)
    let i = 0

    for i in 0..line_count:
        let line = List.get(lines, i)
        let trimmed = String.trim(line)

        # Skip preprocessor and comments
        if String.starts_with(trimmed, "#"):
            continue
        if String.starts_with(trimmed, "//"):
            continue

        # Check for function pattern
        if is_function_start(trimmed):
            let func_name = extract_function_name(trimmed)
            let start_line = i + 1

            # Parse doc comment before the function
            let doc_result = parse_doc_comment(lines, i)
            let has_doc: Bool = doc_result.0
            let doc_params: List(String) = doc_result.1
            let has_return_doc: Bool = doc_result.2

            # Extract parameter names and return type from signature
            let param_names = extract_param_names(trimmed)
            let return_type = extract_return_type(trimmed)

            # Find function end by matching braces
            let result = find_function_end(lines, i)
            let end_line: Int = result.0
            let body: String = result.1

            # Include doc comment info in body for @return check
            let body = if has_return_doc: body + "\n@return" else: body

            # Count assertions in body
            let assertions = count_assertions(body)

            let func = (func_name, start_line, end_line, assertions, body, has_doc, param_names, return_type, doc_params)
            let functions = List.push(functions, func)

    functions

# Parse documentation comment before a function
# Returns (has_doc, documented_params, has_return)
fn parse_doc_comment(lines: List(String), func_line_idx: Int) -> (Bool, List(String), Bool):
    let search_start = if func_line_idx > 30: func_line_idx - 30 else: 0
    parse_doc_comment_rec(lines, func_line_idx - 1, search_start)

fn parse_doc_comment_rec(lines: List(String), idx: Int, search_start: Int) -> (Bool, List(String), Bool):
    let empty_params: List(String) = []
    if idx < search_start:
        (false, empty_params, false)
    else:
        let line: String = List.get(lines, idx)
        let trimmed = String.trim(line)

        # Check for end of block comment
        if String.ends_with(trimmed, "*/"):
            # Found potential doc comment, search backwards for start
            find_block_comment_start(lines, idx, search_start)
        else:
            # Check for /// style comments
            if String.starts_with(trimmed, "///"):
                collect_triple_slash_comment(lines, idx, search_start)
            else:
                # Check for empty line or other content
                if String.len(trimmed) == 0:
                    parse_doc_comment_rec(lines, idx - 1, search_start)
                else:
                    # Non-comment content before function
                    if String.starts_with(trimmed, "//"):
                        parse_doc_comment_rec(lines, idx - 1, search_start)
                    else:
                        (false, empty_params, false)

# Find the start of a block comment and extract @param/@return
fn find_block_comment_start(lines: List(String), end_idx: Int, search_start: Int) -> (Bool, List(String), Bool):
    let empty_params: List(String) = []
    find_block_comment_start_rec(lines, end_idx, end_idx, search_start, empty_params, false)

fn find_block_comment_start_rec(lines: List(String), current_idx: Int, end_idx: Int, search_start: Int, params: List(String), has_return: Bool) -> (Bool, List(String), Bool):
    let empty_params: List(String) = []
    if current_idx < search_start:
        (false, empty_params, false)
    else:
        let line: String = List.get(lines, current_idx)
        let trimmed = String.trim(line)

        # Extract @param names from this line
        let params = if String.contains(line, "@param"):
            extract_param_from_doc_line(line, params)
        else:
            params

        # Check for @return
        let has_return = has_return or String.contains(line, "@return")

        # Check for start of block comment
        if String.starts_with(trimmed, "/**") or String.starts_with(trimmed, "/*"):
            # Found the start - check if it has description
            let has_desc = has_doc_description(lines, current_idx, end_idx)
            (has_desc, params, has_return)
        else:
            find_block_comment_start_rec(lines, current_idx - 1, end_idx, search_start, params, has_return)

# Check if doc comment has a description (not just @tags)
fn has_doc_description(lines: List(String), start_idx: Int, end_idx: Int) -> Bool:
    has_doc_description_rec(lines, start_idx, end_idx)

fn has_doc_description_rec(lines: List(String), idx: Int, end_idx: Int) -> Bool:
    if idx > end_idx:
        false
    else:
        let line: String = List.get(lines, idx)
        # Strip comment markers and check for non-tag content
        let content = String.trim(line)
        let content = strip_comment_markers(content)
        let content = String.trim(content)

        # Skip empty lines and lines starting with @
        if String.len(content) == 0:
            has_doc_description_rec(lines, idx + 1, end_idx)
        else:
            if String.starts_with(content, "@"):
                has_doc_description_rec(lines, idx + 1, end_idx)
            else:
                # Found description text
                true

# Strip /** /* */ * // markers from a line
fn strip_comment_markers(line: String) -> String:
    let line = if String.starts_with(line, "/**"): String.slice(line, 3, String.len(line)) else: line
    let line = if String.starts_with(line, "/*"): String.slice(line, 2, String.len(line)) else: line
    let line = if String.ends_with(line, "*/"): String.slice(line, 0, String.len(line) - 2) else: line
    let line = if String.starts_with(line, "*"): String.slice(line, 1, String.len(line)) else: line
    let line = if String.starts_with(line, "///"): String.slice(line, 3, String.len(line)) else: line
    let line = if String.starts_with(line, "//"): String.slice(line, 2, String.len(line)) else: line
    line

# Extract @param name from a doc comment line
fn extract_param_from_doc_line(line: String, params: List(String)) -> List(String):
    # Find @param and extract the word after it
    let parts = String.split(line, "@param")
    if List.len(parts) < 2:
        params
    else:
        let after_param: String = List.get(parts, 1)
        let after_param = String.trim(after_param)
        # Get first word (the parameter name)
        let words = String.split(after_param, " ")
        if List.is_empty(words):
            params
        else:
            let param_name: String = List.head(words)
            List.push(params, param_name)

# Collect /// style comments
fn collect_triple_slash_comment(lines: List(String), start_idx: Int, search_start: Int) -> (Bool, List(String), Bool):
    let empty_params: List(String) = []
    collect_triple_slash_rec(lines, start_idx, search_start, empty_params, false, false)

fn collect_triple_slash_rec(lines: List(String), idx: Int, search_start: Int, params: List(String), has_return: Bool, has_desc: Bool) -> (Bool, List(String), Bool):
    if idx < search_start:
        (has_desc, params, has_return)
    else:
        let line: String = List.get(lines, idx)
        let trimmed = String.trim(line)

        if String.starts_with(trimmed, "///"):
            # Extract @param if present
            let params = if String.contains(line, "@param"):
                extract_param_from_doc_line(line, params)
            else:
                params

            # Check for @return
            let has_return = has_return or String.contains(line, "@return")

            # Check for description (non-empty, non-@ content)
            let content = String.slice(trimmed, 3, String.len(trimmed))
            let content = String.trim(content)
            let has_desc = has_desc or (String.len(content) > 0 and not String.starts_with(content, "@"))

            collect_triple_slash_rec(lines, idx - 1, search_start, params, has_return, has_desc)
        else:
            if String.len(trimmed) == 0:
                collect_triple_slash_rec(lines, idx - 1, search_start, params, has_return, has_desc)
            else:
                (has_desc, params, has_return)

# Extract parameter names from function signature
fn extract_param_names(sig: String) -> List(String):
    let empty: List(String) = []
    # Find the part between parentheses
    let parts = String.split(sig, "(")
    if List.len(parts) < 2:
        empty
    else:
        let after_paren: String = List.get(parts, 1)
        let parts2 = String.split(after_paren, ")")
        if List.is_empty(parts2):
            empty
        else:
            let params_str: String = List.head(parts2)
            let params_str = String.trim(params_str)
            if String.eq(params_str, "") or String.eq(params_str, "void"):
                empty
            else:
                # Split by comma and extract last word from each
                let param_parts = String.split(params_str, ",")
                extract_param_names_from_parts(param_parts, empty)

fn extract_param_names_from_parts(parts: List(String), result: List(String)) -> List(String):
    if List.is_empty(parts):
        result
    else:
        let part: String = List.head(parts)
        let rest = List.tail(parts)
        let part = String.trim(part)
        # Handle ... for varargs
        if String.contains(part, "..."):
            let result = List.push(result, "...")
            extract_param_names_from_parts(rest, result)
        else:
            # Get last word (possibly with *)
            let words = String.split(part, " ")
            let last_word = get_last_word(words)
            # Remove leading *
            let name = if String.starts_with(last_word, "*"): String.slice(last_word, 1, String.len(last_word)) else: last_word
            if String.eq(name, "") or String.eq(name, "void"):
                extract_param_names_from_parts(rest, result)
            else:
                let result = List.push(result, name)
                extract_param_names_from_parts(rest, result)

fn get_last_word(words: List(String)) -> String:
    if List.is_empty(words):
        ""
    else:
        let head: String = List.head(words)
        let tail = List.tail(words)
        if List.is_empty(tail):
            head
        else:
            get_last_word(tail)

# Extract return type from function signature
fn extract_return_type(sig: String) -> String:
    let empty: List(String) = []
    # Everything before the function name (last word before '(')
    let parts = String.split(sig, "(")
    if List.is_empty(parts):
        ""
    else:
        let before_paren: String = List.head(parts)
        let before_paren = String.trim(before_paren)
        let words = String.split(before_paren, " ")
        # All words except the last one form the return type
        extract_return_type_from_words(words, empty)

fn extract_return_type_from_words(words: List(String), result: List(String)) -> String:
    if List.is_empty(words):
        ""
    else:
        let tail = List.tail(words)
        if List.is_empty(tail):
            # Last word is the function name, join the accumulated result
            String.join(result, " ")
        else:
            let head: String = List.head(words)
            let result = List.push(result, head)
            extract_return_type_from_words(tail, result)

# Check if line looks like a function definition start
fn is_function_start(line: String) -> Bool:
    # Must contain '(' and end with '{'
    let has_paren = String.contains(line, "(")
    let ends_brace = String.ends_with(line, "{")

    if not has_paren or not ends_brace:
        false
    else:
        # Skip control structures
        let is_control = is_control_structure(line)
        if is_control:
            false
        else:
            # Check for common type prefixes
            is_type_prefix(line)

# Check if line is a control structure (if, while, for, switch)
fn is_control_structure(line: String) -> Bool:
    let has_if = String.contains(line, "if (") or String.contains(line, "if(")
    let has_while = String.contains(line, "while (") or String.contains(line, "while(")
    let has_for = String.contains(line, "for (") or String.contains(line, "for(")
    let has_switch = String.contains(line, "switch (") or String.contains(line, "switch(")
    has_if or has_while or has_for or has_switch

# Check if line starts with a type prefix
fn is_type_prefix(line: String) -> Bool:
    # Common C type prefixes - use helper to avoid early return issue
    let c_prefixes = ["static ", "void ", "int ", "int64_t ", "char ", "char* ", "bool ", "size_t ", "const "]
    # Fern types - include pointer variants
    let fern_types = ["String*", "String ", "Type*", "Type ", "Expr*", "Expr ", "Token*", "Token ",
                      "Lexer*", "Lexer ", "Parser*", "Parser ", "Checker*", "Checker ",
                      "Codegen*", "Codegen ", "Arena*", "Arena ", "Fern", "PrintType",
                      "MatchArm*", "MatchArm ", "Pattern*", "Pattern ", "Stmt*", "Stmt ",
                      "TypeDef*", "TypeDef ", "RecordField*", "RecordField ", "MapEntry*", "MapEntry "]
    has_any_prefix(line, c_prefixes) or has_any_prefix(line, fern_types)

# Helper: check if line starts with any prefix in list (recursive to avoid return in for loop)
fn has_any_prefix(line: String, prefixes: List(String)) -> Bool:
    if List.is_empty(prefixes):
        false
    else:
        let p: String = List.head(prefixes)
        if String.starts_with(line, p):
            true
        else:
            has_any_prefix(line, List.tail(prefixes))

# Extract function name from definition line
fn extract_function_name(line: String) -> String:
    # Find the part before '('
    let parts = String.split(line, "(")
    if List.len(parts) == 0:
        "unknown"
    else:
        extract_name_from_parts(parts)

# Helper to extract name from parts (avoids early return)
fn extract_name_from_parts(parts: List(String)) -> String:
    let before_paren: String = List.get(parts, 0)
    let words = String.split(String.trim(before_paren), " ")

    # Last word is the function name (possibly with *)
    let last_idx = List.len(words) - 1
    if last_idx < 0:
        "unknown"
    else:
        let name: String = List.get(words, last_idx)
        # Remove leading * if present
        if String.starts_with(name, "*"):
            String.slice(name, 1, String.len(name))
        else:
            name

# Find the end of a function and return (end_line, body_text)
fn find_function_end(lines: List(String), start_idx: Int) -> (Int, String):
    let line_count = List.len(lines)
    let empty_lines: List(String) = []
    find_function_end_rec(lines, start_idx, line_count, 0, empty_lines, false)

# Recursive helper to find function end (avoids return in for loop)
fn find_function_end_rec(lines: List(String), idx: Int, line_count: Int, brace_count: Int, body_lines: List(String), found_first: Bool) -> (Int, String):
    if idx >= line_count:
        # Reached end without finding closing brace
        let body = String.join(body_lines, "\n")
        (line_count, body)
    else:
        let line: String = List.get(lines, idx)
        let body_lines = List.push(body_lines, line)

        # Count braces, ignoring those inside string literals
        let brace_counts = count_braces_outside_strings(line)
        let open_braces: Int = brace_counts.0
        let close_braces: Int = brace_counts.1
        let brace_count = brace_count + open_braces - close_braces

        let found_first = found_first or brace_count > 0

        if found_first and brace_count == 0:
            let body = String.join(body_lines, "\n")
            (idx + 1, body)
        else:
            find_function_end_rec(lines, idx + 1, line_count, brace_count, body_lines, found_first)

# Count braces in a line, ignoring those inside string literals
# Returns (open_braces, close_braces)
fn count_braces_outside_strings(line: String) -> (Int, Int):
    count_braces_rec(line, 0, String.len(line), false, 0, 0, 0)

fn count_braces_rec(line: String, idx: Int, len: Int, in_string: Bool, string_char: Int, opens: Int, closes: Int) -> (Int, Int):
    if idx >= len:
        (opens, closes)
    else:
        let char_opt = String.char_at(line, idx)
        match char_opt:
            None -> (opens, closes),
            Some(c) -> count_brace_char(line, idx, len, in_string, string_char, opens, closes, c)

fn count_brace_char(line: String, idx: Int, len: Int, in_string: Bool, string_char: Int, opens: Int, closes: Int, c: Int) -> (Int, Int):
    if not in_string:
        # Check for start of string
        if c == 34 or c == 39:  # " or '
            count_braces_rec(line, idx + 1, len, true, c, opens, closes)
        else:
            if c == 123:  # {
                count_braces_rec(line, idx + 1, len, false, 0, opens + 1, closes)
            else:
                if c == 125:  # }
                    count_braces_rec(line, idx + 1, len, false, 0, opens, closes + 1)
                else:
                    count_braces_rec(line, idx + 1, len, false, 0, opens, closes)
    else:
        # Inside string
        if c == 92:  # backslash - skip next char too
            count_braces_rec(line, idx + 2, len, true, string_char, opens, closes)
        else:
            if c == string_char:
                # End of string
                count_braces_rec(line, idx + 1, len, false, 0, opens, closes)
            else:
                # Inside string - ignore
                count_braces_rec(line, idx + 1, len, true, string_char, opens, closes)

# Count occurrences of a character (as ASCII code) in a string
fn count_char(s: String, ch: Int) -> Int:
    let count = 0
    let len = String.len(s)
    for i in 0..len:
        let char_opt = String.char_at(s, i)
        let count = match char_opt:
            Some(c) -> if c == ch: count + 1 else: count,
            None -> count
        ()
    count

# Count assert() calls in function body
fn count_assertions(body: String) -> Int:
    let parts = String.split(body, "assert(")
    List.len(parts) - 1
